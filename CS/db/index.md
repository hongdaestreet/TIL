# 인덱스

테이블의 동작 속도를 높여 주는 부분을 정의함

즉, 자료구조임. B- Tree 기반임. 3갈래로 나눠져 낮은 depth로 위치 파악 가능함 → O(log N)

일반 자료면 O(N) 

클러스터 인덱스 - 별도의 공간이 필요함?

### Clustered Index

필수적으로 사용하고 있는 인덱스 (PK)

테이블당 하나만 잡을 수 있음

정렬되어 있음

```sql
ALTER TABLE IDX ADD PRIMARY KEY(COL1);  -- 인덱스 생성 (PK)
```

### None Clustered Index

pk외에 

```sql
CREATE INDEX IDX on TABLENAME(COL1,COL2);
```

인덱스 구현 안 할 때도 많음 → 사실 많이 쓸 일 없음

MSA했지만 서비스 전체에 막대한 영향 끼칠 수도 있음

 

상용화된 DB → index 자동으로 들어가있음

optimizer로 미리 값을 받을 수 있음? 

프로시저?

### When?

1. 규모가 작지 않은 테이블
2. INSERT, UPDATE, DELETE(쓰지 마)가 자주 발생하지 않는 COLUMN
3. JOIN,WHERE,ORDER BY에 자주 사용되는 COLUMN
4. 데이터의 중복도가 낮은 COLUMN

### 장점

1. 테이블 조회 속도 · 성능 향상
2. 시스템 부하 줄일 수 있음

### 단점

1. 인덱스 관리하기 위해 10% 정도 저장공간 팔요
2. 역효과날 수 있음
    1. CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸면 인덱스 크기가 커져서 성능이 저하될 수 있음
3. 

### 주의점

1. Index 관리를 위한 추가 작업 - 별도의 인덱스 테이블 생성됨
    1. INSERT: 새로운 데이터에 대한 인덱스 추가
    2. DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
    3. UPDATE: 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가
2. 추가 저장 공간 필요 - CPU 사용 (버퍼 사용)
3. 잘못 사용하는 경우 성능 저하 가능성

### 다중 컬럼 Index

두 개 이상의 필드를 조합한 index ** 복합키랑 다름

---

### Index 설계 방법

1. 무조건 많이 설정하지 않는다
2. 조회시 자주 사용하는 컬럼
3. 고유한 값 위주로 설계
4. 카디널리티가 높을 수록 좋다
5. index 키의 크기는 되도록 작게 설계
6. PK,JOIN의 연결고리가 되는 컬럼
7. 단일 인덱스 여러 개보다 다중 index 생성 고려
8. UPDATE가 빈번하지 않은 컬럼
9. join시 자주 사용하는 컬럼
10. index를 생성할 때 가장 효율적인 자료형은 정수형 자료(가변적 데이터는 비효율적) 

---

### 선택도

(column의 특정 값의 row수/총 row수) *100

### 활용도

해당 칼럼이 실제 작업에서 활용되는지에 대한 정보

|  |  |
| --- | --- |
| 카디널리티 | 높을수록 좋음 |
| 선택도 | 낮을 수록 좋음(5~10%) |
| 활용도 | 높을수록 좋음 |